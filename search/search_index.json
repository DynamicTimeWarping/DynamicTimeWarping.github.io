{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the Dynamic Time Warp suite! The packages dtw for R and dtw-python for Python provide the most complete, freely-available (GPL) implementation of Dynamic Time Warping-type (DTW) algorithms up to date. They support arbitrary local (eg symmetric, asymmetric, slope-limited) and global (windowing) constraints, fast native code, several plot styles, and more. DTW is a family of algorithms which compute the local stretch or compression to apply to the time axes of two timeseries in order to optimally map one (query) onto the other (reference). DTW outputs the remaining cumulative distance between the two and, if desired, the mapping itself (warping function). DTW is widely used for classification and clustering tasks, e.g. in bioinformatics, chemometrics, econometrics, and general timeseries mining. The R package is described in a companion paper which includes detailed instructions and extensive background on things like multivariate matching, open-end variants for real-time use, interplay between recursion types and length normalization, history, etc. The dtw-python module on PyPi is its direct Python equivalent. Availability R : the dtw package on CRAN Python : the dtw-python package on PyPI Both are available for all major platforms and regularly tested and built via continuous integration. Source code is available on GitHub and in the CRAN package. Features The implementation provides: arbitrary windowing functions (global constraints), eg. the Sakoe-Chiba band and the Itakura parallelogram ; arbitrary transition types (also known as step patterns, slope constraints, local constraints, or DP-recursion rules). This includes dozens of well-known types: all step patterns classified by Rabiner-Juang , Sakoe-Chiba , and Rabiner-Myers ; symmetric and asymmetric; Rabiner's smoothed variants; arbitrary, user-defined slope constraints partial matches: open-begin, open-end, substring matches proper, pattern-dependent, normalization (exact average distance per step) the Minimum Variance Matching (MVM) algorithm (Latecki et al.) In addition to computing alignments, the package provides: methods for plotting alignments and warping functions in several classic styles (see plot gallery); graphical representation of step patterns; functions for applying a warping function, either direct or inverse; fast native (C) core. Multivariate timeseries can be aligned with arbitrary local distance definitions, leveraging the proxy::dist (R) or scipy.spatial.distance.cdist (Python) functions. Documentation The best place to learn how to use the package (and a hopefully a good deal of background on DTW) is the companion paper Computing and Visualizing Dynamic Time Warping Alignments in R: The dtw Package , freely available from the Journal of Statistical Software. It includes detailed instructions and extensive background on things like multivariate matching, open-end variants for real-time use, interplay between recursion types and length normalization, history, etc. To learn how the dtw package is used in domains ranging from bioinformatics to chemistry to data mining, please see the list of citing papers . The R and Python pages contain links to programming language-specific documentation. (Note: R is the prime environment for the DTW suite. Python is functionally equivalent, but part of the documentation is translated automatically and may not be as pretty.) Quickstart Ready-to-try examples are available in the DTW for R and DTW for Python pages. Plot gallery See a gallery of sample plots , straight out of the examples in the documentation. Citation If you use dtw , do cite it in any publication reporting results obtained with this software. Please follow the directions given in citation(\"dtw\") , i.e. cite: Toni Giorgino (2009). Computing and Visualizing Dynamic Time Warping Alignments in R: The dtw Package. Journal of Statistical Software, 31(7), 1-24, doi:10.18637/jss.v031.i07 . When using partial matching (unconstrained endpoints via the open.begin / open.end options) and/or normalization strategies, please also cite: Paolo Tormene, Toni Giorgino, Silvana Quaglini, Mario Stefanelli (2008). Matching Incomplete Time Series with Dynamic Time Warping: An Algorithm and an Application to Post-Stroke Rehabilitation. Artificial Intelligence in Medicine, 45(1), 11-34. doi:10.1016/j.artmed.2008.11.007 License This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with this program. If not, see https://www.gnu.org/licenses/ . Contact I am happy to provide support and seminars to academic and public research institutions. For seminars, please indicate dates, preferred format, and audience type. Toni dot Giorgino at gmail.com Istituto di Biofisica (IBF-CNR) Consiglio Nazionale delle Ricerche c/o Dept. of Biosciences, University of Milan Milano, Italy Commercial support Research contracts for on-site and remote R&D for commercial companies are available through the Biophysics Institute .","title":"Home"},{"location":"#welcome-to-the-dynamic-time-warp-suite","text":"The packages dtw for R and dtw-python for Python provide the most complete, freely-available (GPL) implementation of Dynamic Time Warping-type (DTW) algorithms up to date. They support arbitrary local (eg symmetric, asymmetric, slope-limited) and global (windowing) constraints, fast native code, several plot styles, and more. DTW is a family of algorithms which compute the local stretch or compression to apply to the time axes of two timeseries in order to optimally map one (query) onto the other (reference). DTW outputs the remaining cumulative distance between the two and, if desired, the mapping itself (warping function). DTW is widely used for classification and clustering tasks, e.g. in bioinformatics, chemometrics, econometrics, and general timeseries mining. The R package is described in a companion paper which includes detailed instructions and extensive background on things like multivariate matching, open-end variants for real-time use, interplay between recursion types and length normalization, history, etc. The dtw-python module on PyPi is its direct Python equivalent.","title":"Welcome to the Dynamic Time Warp suite!"},{"location":"#availability","text":"R : the dtw package on CRAN Python : the dtw-python package on PyPI Both are available for all major platforms and regularly tested and built via continuous integration. Source code is available on GitHub and in the CRAN package.","title":"Availability"},{"location":"#features","text":"The implementation provides: arbitrary windowing functions (global constraints), eg. the Sakoe-Chiba band and the Itakura parallelogram ; arbitrary transition types (also known as step patterns, slope constraints, local constraints, or DP-recursion rules). This includes dozens of well-known types: all step patterns classified by Rabiner-Juang , Sakoe-Chiba , and Rabiner-Myers ; symmetric and asymmetric; Rabiner's smoothed variants; arbitrary, user-defined slope constraints partial matches: open-begin, open-end, substring matches proper, pattern-dependent, normalization (exact average distance per step) the Minimum Variance Matching (MVM) algorithm (Latecki et al.) In addition to computing alignments, the package provides: methods for plotting alignments and warping functions in several classic styles (see plot gallery); graphical representation of step patterns; functions for applying a warping function, either direct or inverse; fast native (C) core. Multivariate timeseries can be aligned with arbitrary local distance definitions, leveraging the proxy::dist (R) or scipy.spatial.distance.cdist (Python) functions.","title":"Features"},{"location":"#documentation","text":"The best place to learn how to use the package (and a hopefully a good deal of background on DTW) is the companion paper Computing and Visualizing Dynamic Time Warping Alignments in R: The dtw Package , freely available from the Journal of Statistical Software. It includes detailed instructions and extensive background on things like multivariate matching, open-end variants for real-time use, interplay between recursion types and length normalization, history, etc. To learn how the dtw package is used in domains ranging from bioinformatics to chemistry to data mining, please see the list of citing papers . The R and Python pages contain links to programming language-specific documentation. (Note: R is the prime environment for the DTW suite. Python is functionally equivalent, but part of the documentation is translated automatically and may not be as pretty.)","title":"Documentation"},{"location":"#quickstart","text":"Ready-to-try examples are available in the DTW for R and DTW for Python pages.","title":"Quickstart"},{"location":"#plot-gallery","text":"See a gallery of sample plots , straight out of the examples in the documentation.","title":"Plot gallery"},{"location":"#citation","text":"If you use dtw , do cite it in any publication reporting results obtained with this software. Please follow the directions given in citation(\"dtw\") , i.e. cite: Toni Giorgino (2009). Computing and Visualizing Dynamic Time Warping Alignments in R: The dtw Package. Journal of Statistical Software, 31(7), 1-24, doi:10.18637/jss.v031.i07 . When using partial matching (unconstrained endpoints via the open.begin / open.end options) and/or normalization strategies, please also cite: Paolo Tormene, Toni Giorgino, Silvana Quaglini, Mario Stefanelli (2008). Matching Incomplete Time Series with Dynamic Time Warping: An Algorithm and an Application to Post-Stroke Rehabilitation. Artificial Intelligence in Medicine, 45(1), 11-34. doi:10.1016/j.artmed.2008.11.007","title":"Citation"},{"location":"#license","text":"This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with this program. If not, see https://www.gnu.org/licenses/ .","title":"License"},{"location":"#contact","text":"I am happy to provide support and seminars to academic and public research institutions. For seminars, please indicate dates, preferred format, and audience type. Toni dot Giorgino at gmail.com Istituto di Biofisica (IBF-CNR) Consiglio Nazionale delle Ricerche c/o Dept. of Biosciences, University of Milan Milano, Italy","title":"Contact"},{"location":"#commercial-support","text":"Research contracts for on-site and remote R&D for commercial companies are available through the Biophysics Institute .","title":"Commercial support"},{"location":"faq/","text":"Frequently asked questions General How do I choose a step pattern? This question has been raised on Stack Overflow; see here , here and here . A good first guess is symmetric2 (the default), i.e. g[i,j] = min( g[i-1,j-1] + 2 * d[i ,j ] , g[i ,j-1] + d[i ,j ] , g[i-1,j ] + d[i ,j ] , ) What's all the fuss about normalization? What's wrong with the symmetric1 recursion I found in Wikipedia/in another implementation? An alignment computed with a non-normalizable step pattern has two serious drawbacks: It cannot be meaningfully normalized by timeseries length. Hence, longer timeseries have naturally higher distances, in turn making comparisons impossible. It favors diagonal steps, therefore it is not robust: two paths differing for a small local change (eg. horizontal+vertical step rather than diagonal) have very different costs. This is discussed in section 3.2 of the JSS paper , section 4.2 of the AIIM paper , section 4.7 of Rabiner and Juang's Fundamentals of speech recognition book, and elsewhere. Make sure you familiarize yourself with those references. TLDR: just stick to the default symmetric2 recursion and use the value of normalizedDistance . Can you explain it again in different words? Normalization means dividing the total distance accumulated along the path by a suitable denominator that accounts for its length. The denominator must be independent from the actual shape of the path, or the DP formulation doesn't apply. Normalizing by path length is crucial when comparing alignments with each other. This implicitly includes, as a notable case, open-end alignments, for which several possible \"truncations\" are compared with each other. If one doesn't normalise, it becomes obvious that shorter alignments would be preferred over long ones, because they would sum fewer distances from fewer (possibly just 1) matched points. Normalizable step patterns have the property that a suitable path-independent denominator can be constructed. Depending on the step pattern, that denominator is usually the length of the query time series, the length of the reference, or their sum. A normalizable step pattern has the property that all its production rules (branches) have a total weight which is proportional to the respective displacement either along the query, or along the reference, or their sum. What about derivative dynamic time warping? That means that one aligns the derivatives of the inputs. Just use the command diff to preprocess the timeseries. Why do changes in dist.method appear to have no effect? Because it only makes a difference when aligning multivariate timeseries. It specifies the \"pointwise\" or local distance used (before the alignment) between the query feature vector at time i , query[i,] and the reference feature vector at time j , ref[j,] . Most distance functions coincide with the Euclidean distance in the one-dimensional case. Note the following: r<-matrix(runif(10),5) # A 2-D timeseries of length 5 s<-matrix(runif(10),5) # Ditto myMethod<-\"Manhattan\" # Or anything else al1<-dtw(r,s,dist.method=myMethod) # Passing the two inputs al2<-dtw(proxy::dist(r,s,method=myMethod)) # Equivalent, passing the distance matrix all.equal(al1,al2) Can the time/memory requirements be relaxed? The first thing you should try is to set the distance.only=TRUE parameter, which skips backtracing and some object copies. Second, consider downsampling the input timeseries. What is the relation between dist and dtw ? There are two very different , totally unrelated uses for dist . This is explained at length in the paper, but let's summarize. If you have two multivariate timeseries, you can feed them to dist to obtain a local distance matrix . You then pass this matrix to dtw(). This is equivalent to passing the two matrices to the dtw() function and specifying a dist.method (see also the next question). If you have many univariate timeseries, instead of iterating over all pairs and applying dtw() to each, you may feed the lot (arranged as a matrix) to proxy::dist with method=\"DTW\" . In this case your code does NOT explicitly call dtw(). This is equivalent to iterating over all pairs; it is also equivalent to using the dtwDist convenience function. Windowing How do I set custom windows? The window.type argument may be passed a custom window function; it must however accept vector arguments. The easiest solution is to create a logical matrix of the same size as the cost matrix and wrap it as in the following example: win.f <- function(iw,jw,query.size, reference.size, window.size, ...) compare.window # Then use: dtw(x, y, window.type = win.f) Is it possible to force alignments to respect specific known control points? Control points or matching pairs force alignment curves to pass through specific points. An alternative way to see them is that the matching control point define \"epoch boundaries\", and timeseries inside matching epochs must be aligned with each other. This task can be enforced through a block-structured windowing function, which can be implemented rather simply e.g. as follows: win.f <- function (iw, jw, window_iw, window_jw,query.size,reference.size,...) outer(window_iw, window_jw, FUN = \"==\") # Then use: dtw(x, y, window.type = win.f) Where window_iw and window_jw would be vectors specifying the \"epochs\" (integers or factors) for the input timeseries. The result of the outer call can also be modified further e.g. to enable some slack around the control points. (Thanks to E. Jarochowska) (Alternatively, perform several alignments for each interval separately, which is more efficient memory- and time-wise). Clustering Can I use the DTW distance to cluster timeseries? Of course. You need to start with a dissimilarity matrix, i.e. a matrix holding in i,j the DTW distance between timeseries i and j . This matrix is fed to the clustering functions. Obtaining the dissimilarity matrix is done differently depending on whether your timeseries are univariate or or multivariate: see the next questions. How do I cluster univariate timeseries of homogeneous length? Arrange the timeseries (single-variate) in a matrix as rows . Make sure you use a symmetric pattern. See dtwDist . How do I cluster multiple multivariate timeseries? You have to handle the loop yourself. Assuming you have data arranged as x[time,component,series] , pseudocode would be: for (i in 1:N) { for (j in 1:N) { result[i,j] <- dtw( dist(x[,,i],x[,,j]), distance.only=T )$normalizedDistance Can I compute a DTW-based dissimilarity matrix out of timeseries of different lengths? Either loop over the inputs yourself, or pad with NAs and use the following code: dtwOmitNA <-function (x,y) { a<-na.omit(x) b<-na.omit(y) return(dtw(a,b,distance.only=TRUE)$normalizedDistance) } ## create a new entry in the registry with two aliases pr_DB$set_entry(FUN = dtwOmitNA, names = c(\"dtwOmitNA\")) d<-dist(dataset, method = \"dtwOmitNA\") Non-discoveries I've discovered a multidimensional/multivariate version of the DTW algorithm! Shall it be included in the package? Alas, most likely you haven't. DTW had been \"multidimensional\" since its conception. Local distances are computed between N -dimensional vectors; feature vectors have been extensively used in speech recognition since the '70s (see e.g. things like MFCC, RASTA, cepstrum, etc). Don't worry: several other people have \"rediscovered\" multivariate DTW already. The dtw package supports the numerous types of multi-dimensional local distances that the proxy package does, as explained in section 3.6 of the paper in JSS . I've discovered a realtime/early detection version of the DTW algorithm! Alas, most likely you haven't. A natural solution for real-time recognition of timeseries is \"unconstrained DTW\", which relaxes one or both endpoint boundary conditions. To my knowledge, the algorithm was published as early as 1978 by Rabiner, Rosenberg, and Levinson under the name UE2-1: see e.g. the mini-review in ( Tormene and Giorgino, 2008 ). Feel also free to learn about the clever algorithms or expositions by Sakurai et al. (2007) ; Latecki (2007) ; Mori et al. (2006) ; Smith-Waterman (1981) ; Rabiner and Schmidt (1980) ; etc. Open-ended alignments (at one or both ends) are available in the dtw package, as described in section 3.5 of the JSS paper . I've discovered a bug in your backtrack algorithm! Alas, most likely you haven't. Doing the backtracking step may be a bit tricky and, in the general case, doing backtracking via steepest descent on the cost matrix is incorrect. Here's a counterexample: > library(dtw) > dm<-matrix(10,4,4)+diag(rep(1,4)) > al<-dtw(dm,k=T,step=symmetric2) > al$localCostMatrix [,1] [,2] [,3] [,4] [1,] *11* *10* 10 10 [2,] 10 11 *10* 10 [3,] 10 10 11 *10* [4,] 10 10 10 *11* > al$costMatrix [,1] [,2] [,3] [,4] [1,] >11< 21 31 41 [2,] 21 >32< 41 51 [3,] 31 41 >52< 61 [4,] 41 51 61 >72< The sum of costs along the correct warping path (above, marked with *..* ), starting from [1,1] , is 11+10+2*10+2*10+11 = 72, which is correct ( =g[4,4] ). If you follow a backtracking \"steepest descent\" on the cost matrix (below, marked with >..< ), you get the diagonal, with a total cost of 11+2*11+2*11+2*11=77, which is wrong.","title":"FAQ"},{"location":"faq/#frequently-asked-questions","text":"","title":"Frequently asked questions"},{"location":"faq/#general","text":"","title":"General"},{"location":"faq/#how-do-i-choose-a-step-pattern","text":"This question has been raised on Stack Overflow; see here , here and here . A good first guess is symmetric2 (the default), i.e. g[i,j] = min( g[i-1,j-1] + 2 * d[i ,j ] , g[i ,j-1] + d[i ,j ] , g[i-1,j ] + d[i ,j ] , )","title":"How do I choose a step pattern?"},{"location":"faq/#whats-all-the-fuss-about-normalization-whats-wrong-with-the-symmetric1-recursion-i-found-in-wikipediain-another-implementation","text":"An alignment computed with a non-normalizable step pattern has two serious drawbacks: It cannot be meaningfully normalized by timeseries length. Hence, longer timeseries have naturally higher distances, in turn making comparisons impossible. It favors diagonal steps, therefore it is not robust: two paths differing for a small local change (eg. horizontal+vertical step rather than diagonal) have very different costs. This is discussed in section 3.2 of the JSS paper , section 4.2 of the AIIM paper , section 4.7 of Rabiner and Juang's Fundamentals of speech recognition book, and elsewhere. Make sure you familiarize yourself with those references. TLDR: just stick to the default symmetric2 recursion and use the value of normalizedDistance .","title":"What's all the fuss about normalization? What's wrong with the symmetric1 recursion I found in Wikipedia/in another implementation?"},{"location":"faq/#can-you-explain-it-again-in-different-words","text":"Normalization means dividing the total distance accumulated along the path by a suitable denominator that accounts for its length. The denominator must be independent from the actual shape of the path, or the DP formulation doesn't apply. Normalizing by path length is crucial when comparing alignments with each other. This implicitly includes, as a notable case, open-end alignments, for which several possible \"truncations\" are compared with each other. If one doesn't normalise, it becomes obvious that shorter alignments would be preferred over long ones, because they would sum fewer distances from fewer (possibly just 1) matched points. Normalizable step patterns have the property that a suitable path-independent denominator can be constructed. Depending on the step pattern, that denominator is usually the length of the query time series, the length of the reference, or their sum. A normalizable step pattern has the property that all its production rules (branches) have a total weight which is proportional to the respective displacement either along the query, or along the reference, or their sum.","title":"Can you explain it again in different words?"},{"location":"faq/#what-about-derivative-dynamic-time-warping","text":"That means that one aligns the derivatives of the inputs. Just use the command diff to preprocess the timeseries.","title":"What about derivative dynamic time warping?"},{"location":"faq/#why-do-changes-in-distmethod-appear-to-have-no-effect","text":"Because it only makes a difference when aligning multivariate timeseries. It specifies the \"pointwise\" or local distance used (before the alignment) between the query feature vector at time i , query[i,] and the reference feature vector at time j , ref[j,] . Most distance functions coincide with the Euclidean distance in the one-dimensional case. Note the following: r<-matrix(runif(10),5) # A 2-D timeseries of length 5 s<-matrix(runif(10),5) # Ditto myMethod<-\"Manhattan\" # Or anything else al1<-dtw(r,s,dist.method=myMethod) # Passing the two inputs al2<-dtw(proxy::dist(r,s,method=myMethod)) # Equivalent, passing the distance matrix all.equal(al1,al2)","title":"Why do changes in dist.method appear to have no effect?"},{"location":"faq/#can-the-timememory-requirements-be-relaxed","text":"The first thing you should try is to set the distance.only=TRUE parameter, which skips backtracing and some object copies. Second, consider downsampling the input timeseries.","title":"Can the time/memory requirements be relaxed?"},{"location":"faq/#what-is-the-relation-between-dist-and-dtw","text":"There are two very different , totally unrelated uses for dist . This is explained at length in the paper, but let's summarize. If you have two multivariate timeseries, you can feed them to dist to obtain a local distance matrix . You then pass this matrix to dtw(). This is equivalent to passing the two matrices to the dtw() function and specifying a dist.method (see also the next question). If you have many univariate timeseries, instead of iterating over all pairs and applying dtw() to each, you may feed the lot (arranged as a matrix) to proxy::dist with method=\"DTW\" . In this case your code does NOT explicitly call dtw(). This is equivalent to iterating over all pairs; it is also equivalent to using the dtwDist convenience function.","title":"What is the relation between dist and dtw?"},{"location":"faq/#windowing","text":"","title":"Windowing"},{"location":"faq/#how-do-i-set-custom-windows","text":"The window.type argument may be passed a custom window function; it must however accept vector arguments. The easiest solution is to create a logical matrix of the same size as the cost matrix and wrap it as in the following example: win.f <- function(iw,jw,query.size, reference.size, window.size, ...) compare.window # Then use: dtw(x, y, window.type = win.f)","title":"How do I set custom windows?"},{"location":"faq/#is-it-possible-to-force-alignments-to-respect-specific-known-control-points","text":"Control points or matching pairs force alignment curves to pass through specific points. An alternative way to see them is that the matching control point define \"epoch boundaries\", and timeseries inside matching epochs must be aligned with each other. This task can be enforced through a block-structured windowing function, which can be implemented rather simply e.g. as follows: win.f <- function (iw, jw, window_iw, window_jw,query.size,reference.size,...) outer(window_iw, window_jw, FUN = \"==\") # Then use: dtw(x, y, window.type = win.f) Where window_iw and window_jw would be vectors specifying the \"epochs\" (integers or factors) for the input timeseries. The result of the outer call can also be modified further e.g. to enable some slack around the control points. (Thanks to E. Jarochowska) (Alternatively, perform several alignments for each interval separately, which is more efficient memory- and time-wise).","title":"Is it possible to force alignments to respect specific known control points?"},{"location":"faq/#clustering","text":"","title":"Clustering"},{"location":"faq/#can-i-use-the-dtw-distance-to-cluster-timeseries","text":"Of course. You need to start with a dissimilarity matrix, i.e. a matrix holding in i,j the DTW distance between timeseries i and j . This matrix is fed to the clustering functions. Obtaining the dissimilarity matrix is done differently depending on whether your timeseries are univariate or or multivariate: see the next questions.","title":"Can I use the DTW distance to cluster timeseries?"},{"location":"faq/#how-do-i-cluster-univariate-timeseries-of-homogeneous-length","text":"Arrange the timeseries (single-variate) in a matrix as rows . Make sure you use a symmetric pattern. See dtwDist .","title":"How do I cluster univariate timeseries of homogeneous length?"},{"location":"faq/#how-do-i-cluster-multiple-multivariate-timeseries","text":"You have to handle the loop yourself. Assuming you have data arranged as x[time,component,series] , pseudocode would be: for (i in 1:N) { for (j in 1:N) { result[i,j] <- dtw( dist(x[,,i],x[,,j]), distance.only=T )$normalizedDistance","title":"How do I cluster multiple multivariate timeseries?"},{"location":"faq/#can-i-compute-a-dtw-based-dissimilarity-matrix-out-of-timeseries-of-different-lengths","text":"Either loop over the inputs yourself, or pad with NAs and use the following code: dtwOmitNA <-function (x,y) { a<-na.omit(x) b<-na.omit(y) return(dtw(a,b,distance.only=TRUE)$normalizedDistance) } ## create a new entry in the registry with two aliases pr_DB$set_entry(FUN = dtwOmitNA, names = c(\"dtwOmitNA\")) d<-dist(dataset, method = \"dtwOmitNA\")","title":"Can I compute a DTW-based dissimilarity matrix out of timeseries of different lengths?"},{"location":"faq/#non-discoveries","text":"","title":"Non-discoveries"},{"location":"faq/#ive-discovered-a-multidimensionalmultivariate-version-of-the-dtw-algorithm-shall-it-be-included-in-the-package","text":"Alas, most likely you haven't. DTW had been \"multidimensional\" since its conception. Local distances are computed between N -dimensional vectors; feature vectors have been extensively used in speech recognition since the '70s (see e.g. things like MFCC, RASTA, cepstrum, etc). Don't worry: several other people have \"rediscovered\" multivariate DTW already. The dtw package supports the numerous types of multi-dimensional local distances that the proxy package does, as explained in section 3.6 of the paper in JSS .","title":"I've discovered a multidimensional/multivariate version of the DTW algorithm! Shall it be included in the package?"},{"location":"faq/#ive-discovered-a-realtimeearly-detection-version-of-the-dtw-algorithm","text":"Alas, most likely you haven't. A natural solution for real-time recognition of timeseries is \"unconstrained DTW\", which relaxes one or both endpoint boundary conditions. To my knowledge, the algorithm was published as early as 1978 by Rabiner, Rosenberg, and Levinson under the name UE2-1: see e.g. the mini-review in ( Tormene and Giorgino, 2008 ). Feel also free to learn about the clever algorithms or expositions by Sakurai et al. (2007) ; Latecki (2007) ; Mori et al. (2006) ; Smith-Waterman (1981) ; Rabiner and Schmidt (1980) ; etc. Open-ended alignments (at one or both ends) are available in the dtw package, as described in section 3.5 of the JSS paper .","title":"I've discovered a realtime/early detection version of the DTW algorithm!"},{"location":"faq/#ive-discovered-a-bug-in-your-backtrack-algorithm","text":"Alas, most likely you haven't. Doing the backtracking step may be a bit tricky and, in the general case, doing backtracking via steepest descent on the cost matrix is incorrect. Here's a counterexample: > library(dtw) > dm<-matrix(10,4,4)+diag(rep(1,4)) > al<-dtw(dm,k=T,step=symmetric2) > al$localCostMatrix [,1] [,2] [,3] [,4] [1,] *11* *10* 10 10 [2,] 10 11 *10* 10 [3,] 10 10 11 *10* [4,] 10 10 10 *11* > al$costMatrix [,1] [,2] [,3] [,4] [1,] >11< 21 31 41 [2,] 21 >32< 41 51 [3,] 31 41 >52< 61 [4,] 41 51 61 >72< The sum of costs along the correct warping path (above, marked with *..* ), starting from [1,1] , is 11+10+2*10+2*10+11 = 72, which is correct ( =g[4,4] ). If you follow a backtracking \"steepest descent\" on the cost matrix (below, marked with >..< ), you get the diagonal, with a total cost of 11+2*11+2*11+2*11=77, which is wrong.","title":"I've discovered a bug in your backtrack algorithm!"},{"location":"python/","text":"dtw-python : Dynamic Time Warping in Python The dtw-python module is a faithful Python equivalent of the R package; it provides the same algorithms and options. Warning The (pip) package name is dtw-python ; the import statement is just import dtw . Installation To install the stable version of the package, issue the following command (or uv equivalents): pip install dtw-python Plotting functions require the matplotlib package to be installed, either manually or via the dtw-python[plots] extra. A conda-forge::dtw-python package is available on a best-effort basis (i.e., less well tested). Getting started Begin from the installed documentation: > from dtw import * > ?dtw > help(DTW) Note Note: documentation for the Python module is auto-generated from the R version. It may contain minor inconsistencies. Online documentation The package documentation can also be browsed online . Quickstart import numpy as np ## A noisy sine wave as query idx = np.linspace(0,6.28,num=100) query = np.sin(idx) + np.random.uniform(size=100)/10.0 ## A cosine is for template; sin and cos are offset by 25 samples template = np.cos(idx) ## Find the best match with the canonical recursion formula from dtw import * alignment = dtw(query, template, keep_internals=True) ## Display the warping curve, i.e. the alignment curve alignment.plot(type=\"threeway\") ## Align and plot with the Rabiner-Juang type VI-c unsmoothed recursion dtw(query, template, keep_internals=True, step_pattern=rabinerJuangStepPattern(6, \"c\"))\\ .plot(type=\"twoway\",offset=-2) ## See the recursion relation, as formula and diagram print(rabinerJuangStepPattern(6,\"c\")) rabinerJuangStepPattern(6,\"c\").plot() ## And much more! \u2003 Try online! Differences from R R and Python versions conform with the respective language features and coding conventions. Hence: Indices are 0-based R uses 1-based indexing, whereas Python uses 0-based arrays. Wherever indices are returned (most importantly in the .index1 , .index2 , .index1s and .index2s attributes of alignments), these must be assumed to be 0-based in Python. Hence, indices can be used as subscripts in both environments as natural. Object-oriented methods Python OO method calls use the postfix \"dot\" notation. This mostly affects the plot() methods. Note that non-overloaded functional style such as dtwPlotThreeWay are unaffected. Hence: ## In R plot(alignment, type=\"threeway\") ## In Python alignment.plot(type=\"threeway\") ## or dtwPlotThreeWay(alignment) The alignment class The class name of alignment objects in DTW (all capitals) in Python. Its attributes are accessed with the usual \"dot\" notation (R uses $ as for lists). Dots vs underscores R commonly uses the dot ( . ) separator for function argument names, while Python uses the underscore ( _ ) for the same purpose. The function prototypes reflect this difference. Also, Python does not accept abbreviated argument names. Therefore: ## In R alignment = dtw(query, template, keep.int=TRUE) ## In Python alignment = dtw(query, template, keep_internals=True) Plots The graphing functions have been re-implemented within the matplotlib framework. They return axes objects, which can be used to customize the plot appearance. Uncommon build issues These notes may be relevant when building from source or on unusual platforms. Pre-installing the scipy and numpy packages (e.g. with conda ) will speed up installation. Errors like undefined symbol: alloca (at runtime), or about C99 mode (if compiling from source), are likely due to old system or compiler. If using conda , the following may help: conda install gcc_linux-64 pip install dtw-python Remember to delete cached .whl files.","title":"DTW for Python"},{"location":"python/#dtw-python-dynamic-time-warping-in-python","text":"The dtw-python module is a faithful Python equivalent of the R package; it provides the same algorithms and options. Warning The (pip) package name is dtw-python ; the import statement is just import dtw .","title":"dtw-python: Dynamic Time Warping in Python"},{"location":"python/#installation","text":"To install the stable version of the package, issue the following command (or uv equivalents): pip install dtw-python Plotting functions require the matplotlib package to be installed, either manually or via the dtw-python[plots] extra. A conda-forge::dtw-python package is available on a best-effort basis (i.e., less well tested).","title":"Installation"},{"location":"python/#getting-started","text":"Begin from the installed documentation: > from dtw import * > ?dtw > help(DTW) Note Note: documentation for the Python module is auto-generated from the R version. It may contain minor inconsistencies.","title":"Getting started"},{"location":"python/#online-documentation","text":"The package documentation can also be browsed online .","title":"Online documentation"},{"location":"python/#quickstart","text":"import numpy as np ## A noisy sine wave as query idx = np.linspace(0,6.28,num=100) query = np.sin(idx) + np.random.uniform(size=100)/10.0 ## A cosine is for template; sin and cos are offset by 25 samples template = np.cos(idx) ## Find the best match with the canonical recursion formula from dtw import * alignment = dtw(query, template, keep_internals=True) ## Display the warping curve, i.e. the alignment curve alignment.plot(type=\"threeway\") ## Align and plot with the Rabiner-Juang type VI-c unsmoothed recursion dtw(query, template, keep_internals=True, step_pattern=rabinerJuangStepPattern(6, \"c\"))\\ .plot(type=\"twoway\",offset=-2) ## See the recursion relation, as formula and diagram print(rabinerJuangStepPattern(6,\"c\")) rabinerJuangStepPattern(6,\"c\").plot() ## And much more! \u2003 Try online!","title":"Quickstart"},{"location":"python/#differences-from-r","text":"R and Python versions conform with the respective language features and coding conventions. Hence:","title":"Differences from R"},{"location":"python/#indices-are-0-based","text":"R uses 1-based indexing, whereas Python uses 0-based arrays. Wherever indices are returned (most importantly in the .index1 , .index2 , .index1s and .index2s attributes of alignments), these must be assumed to be 0-based in Python. Hence, indices can be used as subscripts in both environments as natural.","title":"Indices are 0-based"},{"location":"python/#object-oriented-methods","text":"Python OO method calls use the postfix \"dot\" notation. This mostly affects the plot() methods. Note that non-overloaded functional style such as dtwPlotThreeWay are unaffected. Hence: ## In R plot(alignment, type=\"threeway\") ## In Python alignment.plot(type=\"threeway\") ## or dtwPlotThreeWay(alignment)","title":"Object-oriented methods"},{"location":"python/#the-alignment-class","text":"The class name of alignment objects in DTW (all capitals) in Python. Its attributes are accessed with the usual \"dot\" notation (R uses $ as for lists).","title":"The alignment class"},{"location":"python/#dots-vs-underscores","text":"R commonly uses the dot ( . ) separator for function argument names, while Python uses the underscore ( _ ) for the same purpose. The function prototypes reflect this difference. Also, Python does not accept abbreviated argument names. Therefore: ## In R alignment = dtw(query, template, keep.int=TRUE) ## In Python alignment = dtw(query, template, keep_internals=True)","title":"Dots vs underscores"},{"location":"python/#plots","text":"The graphing functions have been re-implemented within the matplotlib framework. They return axes objects, which can be used to customize the plot appearance.","title":"Plots"},{"location":"python/#uncommon-build-issues","text":"These notes may be relevant when building from source or on unusual platforms. Pre-installing the scipy and numpy packages (e.g. with conda ) will speed up installation. Errors like undefined symbol: alloca (at runtime), or about C99 mode (if compiling from source), are likely due to old system or compiler. If using conda , the following may help: conda install gcc_linux-64 pip install dtw-python Remember to delete cached .whl files.","title":"Uncommon build issues"},{"location":"r/","text":"dtw : Dynamic Time Warping in R The dtw package is part of CRAN, the Comprehensive R Archive Network. The R version is the reference implemenation of the algorithms. Installation To install the latest stable version of the package, issue the following command in the R console: > install.packages(\"dtw\") This installs the official package from CRAN and is the only supported installation method. )Packages on conda-forge are maintained by third parties and are not supported.) Getting started Begin from the installed documentation: > library(dtw) > demo(dtw) > ?dtw > ?plot.dtw Online documentation The package manual pages can also be browsed online . Quickstart ## A noisy sine wave as query idx<-seq(0,6.28,len=100); query<-sin(idx)+runif(100)/10; ## A cosine is for template; sin and cos are offset by 25 samples template<-cos(idx) ## Find the best match with the canonical recursion formula library(dtw); alignment<-dtw(query,template,keep=TRUE); ## Display the warping curve, i.e. the alignment curve plot(alignment,type=\"threeway\") ## Align and plot with the Rabiner-Juang type VI-c unsmoothed recursion plot( dtw(query,template,keep=TRUE, step=rabinerJuangStepPattern(6,\"c\")), type=\"twoway\",offset=-2); ## See the recursion relation, as formula and diagram rabinerJuangStepPattern(6,\"c\") plot(rabinerJuangStepPattern(6,\"c\")) ## And much more! \u2003 \u2003 \u2003 Try online!","title":"DTW for R"},{"location":"r/#dtw-dynamic-time-warping-in-r","text":"The dtw package is part of CRAN, the Comprehensive R Archive Network. The R version is the reference implemenation of the algorithms.","title":"dtw: Dynamic Time Warping in R"},{"location":"r/#installation","text":"To install the latest stable version of the package, issue the following command in the R console: > install.packages(\"dtw\") This installs the official package from CRAN and is the only supported installation method. )Packages on conda-forge are maintained by third parties and are not supported.)","title":"Installation"},{"location":"r/#getting-started","text":"Begin from the installed documentation: > library(dtw) > demo(dtw) > ?dtw > ?plot.dtw","title":"Getting started"},{"location":"r/#online-documentation","text":"The package manual pages can also be browsed online .","title":"Online documentation"},{"location":"r/#quickstart","text":"## A noisy sine wave as query idx<-seq(0,6.28,len=100); query<-sin(idx)+runif(100)/10; ## A cosine is for template; sin and cos are offset by 25 samples template<-cos(idx) ## Find the best match with the canonical recursion formula library(dtw); alignment<-dtw(query,template,keep=TRUE); ## Display the warping curve, i.e. the alignment curve plot(alignment,type=\"threeway\") ## Align and plot with the Rabiner-Juang type VI-c unsmoothed recursion plot( dtw(query,template,keep=TRUE, step=rabinerJuangStepPattern(6,\"c\")), type=\"twoway\",offset=-2); ## See the recursion relation, as formula and diagram rabinerJuangStepPattern(6,\"c\") plot(rabinerJuangStepPattern(6,\"c\")) ## And much more! \u2003 \u2003 \u2003 Try online!","title":"Quickstart"}]}